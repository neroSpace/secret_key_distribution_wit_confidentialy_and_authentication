import os, binascii
from Cryptodome.PublicKey import RSA
from Cryptodome.Cipher import PKCS1_OAEP

# Initialize key size
key_size = 2048

# Generate public and private keys for A 
priv_key_A = RSA.generate(key_size)
f = open('priv_key_A.pem','wb')
f.write(priv_key_A.export_key('PEM'))
f.close()

pub_key_A = priv_key_A.publickey()
f = open('pub_key_A.pem','wb')
f.write(pub_key_A.export_key('PEM'))
f.close()

# Generate public and private keys for B
priv_key_B = RSA.generate(key_size)
f = open('priv_key_B.pem','wb')
f.write(priv_key_B.export_key('PEM'))
f.close()

pub_key_B = priv_key_B.publickey()
f = open('pub_key_B.pem','wb')
f.write(pub_key_B.export_key('PEM'))
f.close()

## 1. A uses B's public key to encrypt a message to B containing an identifier of A (IA) and a nonce (N1), which is used to identify this transaction uniquely.
print("Step 1. E(PUb, [N1 || IDa])")

N1 = os.urandom(16)
print("N1: ", binascii.hexlify(N1))

IDa = b"A"
print("IDa: ", IDa)

message_step_1 = {
    'Identifier' : IDa,
    'Nonce_1' : N1
}
# print("message_step_1: ", binascii.hexlify(message_step_1))

message_step_1 = str(message_step_1).encode('utf-8')
print("message_step_1: ", binascii.hexlify(message_step_1))

cipher_B = PKCS1_OAEP.new(pub_key_B)
encrypted_message = cipher_B.encrypt(message_step_1)
print("encrypted_message : ", binascii.hexlify(encrypted_message))

# B receives the message and decrypts it with B's private key
cipher_B = PKCS1_OAEP.new(priv_key_B)
decrypted_message = cipher_B.decrypt(encrypted_message)
print("decrypted_message: ", binascii.hexlify(decrypted_message))
print("----------------------------------------------------------------------------------\n")

#2. B sends a message to A encrypted with PUa and containing A's nonce (N1) as well as a new nonce generated by B (N2). Because only B could have decrypted message (1), the presence of N1 in message (2) assures A that the correspondent is B.
print("Step 2. E(PUa, [N1 || N2])")
# B generates another nonce and sends it back to A encrypted with A's public key
N2 = os.urandom(16)
print("N2: ", binascii.hexlify(N2))

message_step_2 = {
    'Nonce_1' : N1,
    'Nonce_2' : N2
}

message_step_2= str(message_step_2).encode('utf-8')
print("message_step_2: ", binascii.hexlify(message_step_2))

PUa = RSA.importKey(open('pub_key_A.pem').read())
cipher_A = PKCS1_OAEP.new(PUa)
encrypted_message = cipher_A.encrypt(message_step_2)
print("encrypted_message: ", binascii.hexlify(encrypted_message))

# A receives the message and decrypts it with A's private key
PRa = RSA.importKey(open('priv_key_A.pem').read())
cipher_A = PKCS1_OAEP.new(PRa)
decrypted_message = cipher_A.decrypt(encrypted_message)
print("decrypted_message: ", binascii.hexlify(decrypted_message))
print("----------------------------------------------------------------------------------\n")

#3. A sends a message to B encrypted with PUb and containing B's nonce (N2). Because only A could have decrypted message (2), the presence of N2 in message (3) assures B that the correspondent is A.
print("Step 3. E(PUb, N2)")

message_step_3 = {
    'Nonce_2' : N2
}

message_step_3= str(message_step_3).encode('utf-8')
print("message_step_3: ", binascii.hexlify(message_step_3))

PUb = RSA.importKey(open('pub_key_B.pem').read())
cipher_B = PKCS1_OAEP.new(PUb)
encrypted_message = cipher_B.encrypt(message_step_3)
print("encrypted_message : ", binascii.hexlify(encrypted_message))

# B receives the message and decrypts it with B's private key
cipher_B = PKCS1_OAEP.new(priv_key_B)
decrypted_message = cipher_B.decrypt(encrypted_message)
print("decrypted_message: ", binascii.hexlify(decrypted_message))
print("----------------------------------------------------------------------------------\n")


#4. A sends a message to B encrypted with PUb and containing a secret key (Ks) encrypted with A's private key and B's public key.
print("Step 4. E (PUb, E(PRa, Ks))")
# A generates a secret key and encrypts it with A's private key and B's public key
Ks = os.urandom(16)
AtoB_3 = Ks
print("Secret Key: ", binascii.hexlify(AtoB_3))
PRa = RSA.importKey(open('priv_key_A.pem').read())
cipher_A = PKCS1_OAEP.new(PRa)
encrypted_Ks = cipher_A.encrypt(AtoB_3)
print(len(Ks))
print(len(encrypted_Ks))
PUb = RSA.importKey(open('pub_key_B.pem').read())
cipher_B = PKCS1_OAEP.new(PUb)

# Split the message into chunks
chunk_size = 256
chunks = [Ks[i:i+chunk_size] for i in range(0, len(Ks), chunk_size)]

# Encrypt each chunk and concatenate the encrypted chunks
encrypted_chunks = []
for chunk in chunks:
    encrypted_chunks.append(cipher_B.encrypt(chunk))
encrypted_message = b''.join(encrypted_chunks)
# encrypted_message = cipher_B.encrypt(encrypted_Ks)
print("encrypted_message: ", binascii.hexlify(encrypted_message))

# B receives the message and decrypts it with B's private key and A's public key
cipher_B = PKCS1_OAEP.new(priv_key_B)
decrypted_message = cipher_B.decrypt(encrypted_message)
# cipher_A = PKCS1_OAEP.new(pub_key_A)
# decrypted_message = cipher_A.decrypt(decrypted_message)

print("decrypted_message: ", binascii.hexlify(decrypted_message))
print("----------------------------------------------------------------------------------\n")